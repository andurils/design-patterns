# 生成器模式

> 亦称：建造者模式、Builder
![生成器模式](../images/patterns/content/builder/builder-zh.png)

## 意图

生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。与其他创建型模式不同， 生成器不要求产品拥有通用接口。 这使得用相同的创建代码生成不同类型和形式的对象。

使用示例： 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。

识别方法： 生成器模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 生成器方法通常支持方法链 （例如 someBuilder.​setValueA(1).​setValueB(2).​create()）。

## 结构

![生成器模式](../images/patterns/diagrams/builder/structure.png)

- 生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
- 具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
- 产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
- 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
- 客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。

## 应用场景

💡 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

⚡ 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

## 优缺点

- 😁

- 😒

## 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

- 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

- 你可以在创建复杂[组合模式](./composite.md)树时使用生成器， 因为这可使其构造步骤以递归的方式运行。

- 你可以结合使用[生成器](./builder.md)和[桥接模式](./bridge.md)： 主管类负责抽象工作， 各种不同的生成器负责实现工作。

- [抽象工厂](./abstract-factory.md)、 [生成器](./builder.md)和[原型模式](./prototype.md)都可以用[单例模式](./singleton.md)来实现。
