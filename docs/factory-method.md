# 工厂方法模式

> 亦称： 虚拟构造函数、Virtual Constructor、Factory Method

## 意图

工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

工厂方法是一种创建型设计模式， 解决了在不指定具体类的情况下创建产品对象的问题。

工厂方法定义了一个方法， 且必须使用该方法代替通过直接调用构造函数来创建对象 （ new 操作符） 的方式。 子类可重写该方法来更改将被创建的对象所属类。

识别方法： 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。

## 结构

![工厂方法模式](../images/patterns/diagrams/factory-method/structure.png)

- 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
- 具体产品 （Concrete Products） 是产品接口的不同实现。
- 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。
- 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

> 可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

## 应用场景

💡 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

⚡ 工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

💡 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

⚡ 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时，将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

💡 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

⚡ 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。

## 优缺点

- 😁 你可以避免创建者和具体产品之间的紧密耦合。
- 😁 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
- 😁 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

- 😒 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

## 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](./abstract-factory.md) 、 原型模式或生成器模式 （更灵活但更加复杂）。

- [抽象工厂模式](./abstract-factory.md) 通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

- 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

- 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。
